## Code Standards
1. Use TypeScript for all new files with strict type checking.
2. Prefer functional components with hooks over class components.
3. Use App Router (not Pages Router) for new routes.
4. Follow Next.js 14+ conventions and best practices.
5. Use async/await instead of .then() chains.
6. Implement proper error boundaries for React components.

## File Structure
7. Components go in `/components` with PascalCase naming.
8. Shadcn/ui components in `/components/ui/` (auto-generated by CLI).
9. Custom reusable components in `/components/common/`.
10. Page-specific components in `/components/[page-name]/`.
11. Utilities go in `/lib` or `/utils` (including cn() utility from Shadcn).
12. Types go in `/types` directory.
13. Supabase utilities in `/lib/supabase/`.
14. Database types in `/types/database.types.ts`.
15. Use barrel exports (index.ts) for cleaner imports.

## Next.js Best Practices
16. Use Server Components by default, Client Components only when needed.
17. Implement proper loading.tsx and error.tsx files for routes.
18. Use Next.js Image component for all images with proper optimization.
19. Implement proper metadata for SEO in layout.tsx and page.tsx.
20. Use generateStaticParams for dynamic routes when possible.
21. Prefer server actions over API routes for mutations.
22. Use middleware for authentication redirects and route protection.
23. Implement proper caching strategies with revalidation.

## Supabase Integration
24. Always use environment variables for Supabase keys (NEXT_PUBLIC_SUPABASE_URL, SUPABASE_ANON_KEY, SUPABASE_SERVICE_ROLE_KEY).
25. Create separate Supabase clients for server and client components.
26. Use Row Level Security (RLS) policies for all tables.
27. Generate TypeScript types from Supabase schema using `supabase gen types`.
28. Use Supabase Auth helpers for Next.js (@supabase/auth-helpers-nextjs).
29. Implement proper session management with middleware.
30. Use Supabase Storage for file uploads with proper bucket policies.
31. Handle real-time subscriptions properly with cleanup in useEffect.

## Authentication & Security
32. Always validate user sessions on server components.
33. Use Supabase RLS instead of manual permission checks when possible.
34. Implement proper CSRF protection.
35. Sanitize user inputs and validate on both client and server.
36. Use Supabase's built-in authentication flows.
37. Implement proper logout functionality that clears all sessions.

## Database Patterns
38. Use Supabase's generated types for all database operations.
39. Implement proper error handling for database queries.
40. Use transactions for related operations.
41. Follow PostgreSQL naming conventions (snake_case for columns).
42. Use foreign keys and constraints properly.
43. Implement soft deletes when appropriate.

## State Management
44. Use React hooks (useState, useReducer) for local state.
45. Suggest Zustand for global state management.
46. Use TanStack Query for server state and caching.
47. Cache Supabase queries appropriately.
48. Handle optimistic updates for better UX.

## Styling & Components
49. Use Tailwind CSS for styling with Shadcn/ui component system.
50. Use Shadcn/ui components as base components, customize with className prop.
51. Follow Shadcn/ui theming system with CSS variables in globals.css.
52. Use Shadcn's color system: primary, secondary, muted, accent, destructive, border, input, ring.
53. Implement semantic color usage (destructive for errors, muted for secondary text, etc.).
54. Use theme() function in tailwind.config.js for accessing CSS variables.
55. Create custom color variants using CSS variables following Shadcn convention.
56. Support both light and dark themes with proper CSS variable definitions.
57. Use hsl() color format for theme colors to maintain consistency.
58. Leverage Shadcn's theme generator for custom color palettes when needed.
59. Create reusable component variants using cva (class-variance-authority).
60. Use cn() utility function for conditional classes (from @/lib/utils).
61. Implement dark/light mode toggle using next-themes and Shadcn's theme provider.
62. Avoid inline styles unless absolutely necessary.
63. Use Shadcn's design tokens and spacing system consistently.

## Performance
64. Implement proper loading states and skeletons.
65. Use Next.js dynamic imports for heavy components.
66. Optimize bundle size with proper tree shaking.
67. Use React.memo() judiciously for expensive components.
68. Implement proper image optimization and lazy loading.
69. Use Supabase Edge Functions for compute-heavy operations.

## Code Generation
70. Always include proper TypeScript types from Supabase.
71. Add JSDoc comments for complex functions.
72. Include error handling and loading states with Shadcn Toast or Alert components.
73. Follow accessibility best practices (ARIA labels, semantic HTML).
74. Generate proper form validation with libraries like Zod and react-hook-form.
75. Use Shadcn Form components for consistent form styling and validation.
76. Include proper data fetching patterns (Server Components, Client Components, Server Actions).
77. Use Shadcn's Skeleton components for loading states.
78. Implement proper error states with Shadcn Alert or custom error components.

## Dependencies
79. Prefer established, well-maintained packages.
80. Suggest specific versions when recommending new dependencies.
81. Common recommended packages:
    - @supabase/supabase-js
    - @supabase/auth-helpers-nextjs
    - @tanstack/react-query
    - zod (for validation)
    - react-hook-form
    - lucide-react (for icons, compatible with Shadcn)
    - next-themes (for theme switching)
    - class-variance-authority (for component variants)
    - clsx & tailwind-merge (for className utilities).
82. Use `npx shadcn-ui@latest add [component]` for adding new Shadcn components.
83. Explain why a dependency is needed before suggesting it.

## Testing
84. Write unit tests for utility functions.
85. Test Supabase queries with proper mocking.
86. Include integration tests for critical user flows.
87. Test authentication flows thoroughly.

## Environment Setup
<!-- 88. Use separate Supabase projects for development/staging/production -->
89. Implement proper environment variable validation.
90. Use .env.local for local development.
91. Never commit secrets to version control.
92. Use GitHub Secrets for CI/CD environment variables.
93. Create proper .gitignore for Next.js projects (include .env files, .next/, node_modules/).